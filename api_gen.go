package gorgonia 

import (
	"gonum.org/v1/gonum/graph"
	"gorgonia.org/gorgonia/node"
	"gorgonia.org/gorgonia/ops"
)

// Code generated by genapi, which is a API generation tool for Gorgonia. DO NOT EDIT.

 // Abs performs a pointwise abs.
func Abs(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(absOpType, a), a) }
 // Sign performs a pointwise sign.
func Sign(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(signOpType, a), a) }
 // Ceil performs a pointwise ceil.
func Ceil(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(ceilOpType, a), a) }
 // Floor performs a pointwise floor.
func Floor(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(floorOpType, a), a) }
 // Sin performs a pointwise sin.
func Sin(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(sinOpType, a), a) }
 // Cos performs a pointwise cos.
func Cos(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(cosOpType, a), a) }
 // Exp performs a pointwise exp.
func Exp(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(expOpType, a), a) }
 // Log performs a pointwise log.
func Log(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(lnOpType, a), a) }
 // Log2 performs a pointwise log2.
func Log2(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(log2OpType, a), a) }
 // Neg performs a pointwise neg.
func Neg(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(negOpType, a), a) }
 // Square performs a pointwise square.
func Square(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(squareOpType, a), a) }
 // Sqrt performs a pointwise sqrt.
func Sqrt(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(sqrtOpType, a), a) }
 // Inverse performs a pointwise inverse.
func Inverse(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(inverseOpType, a), a) }
 // InverseSqrt performs a pointwise inversesqrt.
func InverseSqrt(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(inverseSqrtOpType, a), a) }
 // Cube performs a pointwise cube.
func Cube(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(cubeOpType, a), a) }
 // Tanh performs a pointwise tanh.
func Tanh(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(tanhOpType, a), a) }
 // Sigmoid performs a pointwise sigmoid.
func Sigmoid(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(sigmoidOpType, a), a) }
 // Log1p performs a pointwise log1p.
func Log1p(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(log1pOpType, a), a) }
 // Expm1 performs a pointwise expm1.
func Expm1(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(expm1OpType, a), a) }
 // Softplus performs a pointwise softplus.
func Softplus(a *Node) (*Node, error) { return unaryOpNode(newElemUnaryOp(softplusOpType, a), a) }
// Add perfors a pointwise add operation.
func Add(a, b *Node) (*Node, error) { return binOpNode(newElemBinOp(addOpType, a, b), a, b) }

// AddOp ...
func NewAddOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(addOpType, children[0], children[1]), nil
	}
}
// Sub perfors a pointwise sub operation.
func Sub(a, b *Node) (*Node, error) { return binOpNode(newElemBinOp(subOpType, a, b), a, b) }

// SubOp ...
func NewSubOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(subOpType, children[0], children[1]), nil
	}
}
// HadamardProd perfors a pointwise hadamardprod operation.
func HadamardProd(a, b *Node) (*Node, error) { return binOpNode(newElemBinOp(mulOpType, a, b), a, b) }

// HadamardProdOp ...
func NewHadamardProdOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(mulOpType, children[0], children[1]), nil
	}
}
// HadamardDiv perfors a pointwise hadamarddiv operation.
func HadamardDiv(a, b *Node) (*Node, error) { return binOpNode(newElemBinOp(divOpType, a, b), a, b) }

// HadamardDivOp ...
func NewHadamardDivOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(divOpType, children[0], children[1]), nil
	}
}
// Pow perfors a pointwise pow operation.
func Pow(a, b *Node) (*Node, error) { return binOpNode(newElemBinOp(powOpType, a, b), a, b) }

// PowOp ...
func NewPowOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(powOpType, children[0], children[1]), nil
	}
}
// Lt perfors a pointwise lt operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Lt(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(ltOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// LtOp ...
func NewLtOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(ltOpType, children[0], children[1]), nil
	}
}
// Gt perfors a pointwise gt operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Gt(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(gtOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// GtOp ...
func NewGtOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(gtOpType, children[0], children[1]), nil
	}
}
// Lte perfors a pointwise lte operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Lte(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(lteOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// LteOp ...
func NewLteOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(lteOpType, children[0], children[1]), nil
	}
}
// Gte perfors a pointwise gte operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Gte(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(gteOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// GteOp ...
func NewGteOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(gteOpType, children[0], children[1]), nil
	}
}
// Eq perfors a pointwise eq operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Eq(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(eqOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// EqOp ...
func NewEqOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(eqOpType, children[0], children[1]), nil
	}
}
// Ne perfors a pointwise ne operation.
//	retSame indicates if the data type of the return value should be the same as the input data type. It defaults to Bool otherwise.
func Ne(a, b *Node, retSame bool) (*Node, error) { op := newElemBinOp(neOpType, a, b)
	op.retSame = retSame
	return binOpNode(op, a, b)
}

// NeOp ...
func NewNeOperation() Operation {
	return func(g graph.WeightedDirected, n node.Node) (ops.Op, error) {
		it := getOrderedChildren(g, n)
		children := make([]*Node, it.Len())
		for i := 0; it.Next(); i++ {
			children[i] = it.Node().(*Node)
		}
		return newElemBinOp(neOpType, children[0], children[1]), nil
	}
}
